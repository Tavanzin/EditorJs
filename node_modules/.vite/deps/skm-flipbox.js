import "./chunk-BUSYA2B4.js";

// node_modules/skm-flipbox/src/helpers/createElement.js
function createElement(tagName, classNames = null, attributes = {}) {
  const el = document.createElement(tagName);
  if (Array.isArray(classNames)) {
    el.classList.add(...classNames);
  } else if (classNames) {
    el.classList.add(classNames);
  }
  for (const attrName in attributes) {
    el[attrName] = attributes[attrName];
  }
  return el;
}

// node_modules/skm-flipbox/src/lib/Slide.js
var Slide = class {
  constructor({ front, back }, index, total, flipBoxInstance) {
    this.front = front;
    this.back = back;
    this.index = index;
    this.totalSlides = total;
    this.flipBoxInstance = flipBoxInstance;
    this.slideContainer = void 0;
  }
  flipSlide() {
    var _a;
    if (!((_a = this.flipBoxInstance) == null ? void 0 : _a.editing)) {
      const currentSlide = this.slideContainer;
      currentSlide.classList.toggle("reveal");
    }
  }
  render() {
    this.slideContainer = createElement("div", ["mySlides", "fade"]);
    const slideIndex = createElement("div", ["slideIndex"], {
      innerHTML: `${this.index + 1}/${this.totalSlides}`
    });
    const frontText = createElement("div", ["front-content", "editable"], {
      innerHTML: `<div>${this.front}</div>`,
      contentEditable: false
    });
    const captionText = createElement("div", ["back-content", "editable"], {
      innerHTML: `<div>${this.back}</div>`,
      contentEditable: false
    });
    this.slideContainer.appendChild(slideIndex);
    this.slideContainer.appendChild(frontText);
    this.slideContainer.appendChild(captionText);
    this.slideContainer.addEventListener("click", () => this.flipSlide());
    if (this.index !== 0) {
      this.slideContainer.style.display = "none";
    }
    return this.slideContainer;
  }
};
var Slide_default = Slide;

// node_modules/skm-flipbox/src/lib/Button.js
var Button = class {
  constructor({ text, onClick, classList, disabled = false }) {
    this.text = text;
    this.onClick = onClick;
    this.classList = classList;
    this.disabled = disabled;
  }
  render() {
    const button = createElement("button", this.classList, {
      innerHTML: this.text,
      disabled: this.disabled
    });
    button.addEventListener("click", (event) => {
      event.preventDefault();
      event.stopPropagation();
      this.onClick();
    });
    return button;
  }
};
var Button_default = Button;

// node_modules/skm-flipbox/src/lib/SlideContainer.js
var SlideContainer = class {
  constructor({ slides, currentSlideIndex }, flipBoxInstance) {
    this.slides = slides;
    this.currentSlideIndex = currentSlideIndex;
    this.flipBoxInstance = flipBoxInstance;
  }
  renderEmptySlide() {
    const emptySlide = createElement("div", ["empty-slide"], {
      id: "skm-empty-slide"
    });
    emptySlide.innerText = "No slide yet";
    return emptySlide;
  }
  render() {
    const slideWrapper = createElement("div", ["slideshow-container"], {
      id: "skm-slider"
    });
    const totalSlides = this.slides.length;
    if (totalSlides > 0) {
      this.slides.forEach((slide, index) => {
        const slideComponent = new Slide_default(
          slide,
          index,
          totalSlides,
          this.flipBoxInstance
        );
        const slideElement = slideComponent.render();
        slideWrapper.appendChild(slideElement);
      });
    }
    if (!totalSlides) {
      const emptyPage = this.renderEmptySlide();
      slideWrapper.appendChild(emptyPage);
    }
    return slideWrapper;
  }
};
var SlideContainer_default = SlideContainer;

// node_modules/skm-flipbox/src/lib/FlipBox.js
import "C:/xampp/htdocs/EditorJsV.2/EditorJs/node_modules/skm-flipbox/src/lib/style.css";
var SKMFlipBox = class {
  static get toolbox() {
    return {
      title: "FlipBox",
      icon: "FB"
    };
  }
  static get enableLineBreaks() {
    return true;
  }
  static get sanitize() {
    return {
      rows: true
    };
  }
  constructor({ data, api }) {
    this.api = api;
    this.data = {
      rows: (data == null ? void 0 : data.rows) ?? []
    };
    this.widgetWrapper = void 0;
    this.editing = false;
    this.currentSlideIndex = 0;
  }
  setEditing(value) {
    this.editing = value;
  }
  render() {
    this.widgetWrapper = createElement("div", ["outer-container"]);
    const slideContainer = new SlideContainer_default(
      {
        slides: this.data.rows,
        currentSlideIndex: this.currentSlideIndex
      },
      this
    ).render();
    const paginationWrapper = this.renderPagination();
    const buttonWrapper = this.renderActions();
    this.widgetWrapper.appendChild(slideContainer);
    this.widgetWrapper.appendChild(paginationWrapper);
    this.widgetWrapper.appendChild(buttonWrapper);
    return this.widgetWrapper;
  }
  renderPagination() {
    const paginationWrapper = createElement("div", ["holder"], {
      id: "skm-pagination"
    });
    this.data.rows.forEach((_, index) => {
      const dotClass = index === this.currentSlideIndex ? ["dot", "active"] : ["dot"];
      const dot = createElement("span", dotClass, {
        onclick: () => {
          this.currentSlideIndex = index;
          this.showSlide(index);
        }
      });
      paginationWrapper.appendChild(dot);
    });
    return paginationWrapper;
  }
  renderActions() {
    const addButton = new Button_default({
      text: "Add",
      classList: ["action", "addButton"],
      onClick: () => {
        this.addSlide();
      }
    }).render();
    const editButton = new Button_default({
      text: "Edit",
      disabled: this.editing || this.data.rows.length === 0,
      classList: ["action", "editIcon"],
      onClick: () => {
        this.editSlide();
      }
    }).render();
    const saveButton = new Button_default({
      text: "Save",
      disabled: !this.editing,
      classList: ["action", "saveButton"],
      onClick: () => {
        this.saveSlide();
      }
    }).render();
    const deleteButton = new Button_default({
      text: "Delete",
      disabled: this.editing || this.data.rows.length === 0,
      classList: ["action", "deleteButton"],
      onClick: () => {
        this.deleteSlide();
      }
    }).render();
    const buttonWrapper = createElement("div", ["button-wrapper"]);
    buttonWrapper.appendChild(addButton);
    buttonWrapper.appendChild(editButton);
    buttonWrapper.appendChild(saveButton);
    buttonWrapper.appendChild(deleteButton);
    return buttonWrapper;
  }
  addSlide() {
    this.setEditing(false);
    const newSlideIndex = this.data.rows.length;
    const emptySlide = document.getElementById("skm-empty-slide");
    if (emptySlide) {
      emptySlide.remove();
    }
    const newSlide = new Slide_default(
      {
        front: `<h3>New Slide title ${newSlideIndex + 1}</h3>`,
        back: `<div>New Slide Content ${newSlideIndex + 1}</div>`
      },
      newSlideIndex,
      this.data.rows.length,
      this
    );
    const rowsCopy = [...this.data.rows];
    rowsCopy[newSlideIndex] = {
      front: newSlide.front,
      back: newSlide.back
    };
    this.data.rows = rowsCopy;
    const sliderContainer = document.getElementById("skm-slider");
    const newSlideElement = newSlide.render(newSlideIndex, true);
    sliderContainer.appendChild(newSlideElement);
    const paginationHolder = document.getElementById("skm-pagination");
    const newDot = createElement("span", ["dot"], {
      onclick: () => this.showSlide(newSlideIndex)
    });
    paginationHolder.appendChild(newDot);
    this.showSlide(newSlideIndex);
    this.updateButtonState();
    this.updateIndex();
  }
  updateIndex() {
    const slides = document.getElementsByClassName("mySlides");
    for (let i = 0; i < slides.length; i++) {
      const slideIndex = slides[i].querySelector(".slideIndex");
      if (slideIndex) {
        slideIndex.innerHTML = `${i + 1}/${this.data.rows.length}`;
      }
    }
  }
  deleteSlide() {
    const index = this.currentSlideIndex;
    if (confirm(`Are you sure you want to delete slide ${index + 1}?`)) {
      this.data.rows.splice(index, 1);
      const slides = document.getElementsByClassName("mySlides");
      const dots = document.getElementsByClassName("dot");
      slides[index].remove();
      dots[index].remove();
      this.updateIndex();
      if (index === this.currentSlideIndex) {
        if (this.currentSlideIndex >= slides.length) {
          this.currentSlideIndex = slides.length - 1;
        }
      } else if (index < this.currentSlideIndex) {
        this.currentSlideIndex--;
      }
      for (let i = 0; i < dots.length; i++) {
        dots[i].onclick = () => this.showSlide(i);
      }
      this.showSlide(this.currentSlideIndex);
      this.updateButtonState();
    }
  }
  editSlide() {
    this.setEditing(true);
    const slides = document.getElementsByClassName("mySlides");
    const currentSlide = slides[this.currentSlideIndex];
    this.setEditable(currentSlide, true);
    const editableFront = currentSlide.querySelector(".front-content");
    const editableBack = currentSlide.querySelector(".back-content");
    if (currentSlide.classList.contains("reveal")) {
      editableBack.focus();
    } else {
      editableFront.focus();
    }
    this.updateButtonState();
  }
  // setCursorToEnd(editableArea) {
  //   const range = document.createRange();
  //   const sel = window.getSelection();
  //   range.selectNodeContents(editableArea);
  //   range.collapse(false); // Place cursor at the end
  //   sel.removeAllRanges();
  //   sel.addRange(range);
  // }
  setEditable(slide, value) {
    slide.querySelector(".front-content").contentEditable = value;
    slide.querySelector(".back-content").contentEditable = value;
    const editableArea = slide.querySelector(".editable");
    if (value) {
      editableArea.classList.add("focus-visible");
      editableArea.focus();
      editableArea.style.caretColor = "black";
    }
    if (!value) {
      editableArea.classList.remove("focus-visible");
    }
  }
  saveSlide() {
    this.setEditing(false);
    const slides = document.getElementsByClassName("mySlides");
    const currentSlide = slides[this.currentSlideIndex];
    this.setEditable(currentSlide, false);
    const frontContent = currentSlide.querySelector(".front-content");
    const backContent = currentSlide.querySelector(".back-content");
    const rowsCopy = [...this.data.rows];
    rowsCopy[this.currentSlideIndex] = {
      front: frontContent.innerHTML,
      back: backContent.innerHTML
    };
    this.data.rows = rowsCopy;
    document.getElementsByClassName("mySlides")[this.currentSlideIndex].classList.remove("isEditing");
    this.updateButtonState();
  }
  updateButtonState() {
    const editIcon = this.widgetWrapper.querySelector(".editIcon");
    const saveButton = this.widgetWrapper.querySelector(".saveButton");
    const deleteButton = this.widgetWrapper.querySelector(".deleteButton");
    if (this.editing) {
      editIcon.disabled = true;
      saveButton.disabled = false;
    } else {
      editIcon.disabled = false;
      saveButton.disabled = true;
    }
    if (this.data.rows.length) {
      deleteButton.disabled = false;
      editIcon.disabled = false;
    } else {
      deleteButton.disabled = true;
      editIcon.disabled = true;
    }
  }
  revealSlide(index) {
    if (!this.editing) {
      const slides = document.getElementsByClassName("mySlides");
      const currentSlide = slides[index];
      currentSlide.classList.toggle("reveal");
    }
  }
  showSlide(index) {
    this.currentSlideIndex = index;
    const slides = document.getElementsByClassName("mySlides");
    const dots = document.getElementsByClassName("dot");
    for (let i = 0; i < slides.length; i++) {
      if (i === index) {
        slides[i].style.display = "block";
        slides[i].classList.add("fade");
      } else {
        slides[i].style.display = "none";
        slides[i].classList.remove("fade");
      }
    }
    for (let i = 0; i < dots.length; i++) {
      if (i === index) {
        dots[i].classList.add("active");
      } else {
        dots[i].classList.remove("active");
      }
    }
  }
  save(_blockContent) {
    return {
      rows: this.data.rows
    };
  }
};
var FlipBox_default = SKMFlipBox;

// node_modules/skm-flipbox/src/main.js
var main_default = FlipBox_default;
export {
  main_default as default
};
//# sourceMappingURL=skm-flipbox.js.map
